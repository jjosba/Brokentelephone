package fi.utu.tech.telephonegame.network;

import java.io.IOException;
import java.net.DatagramPacket;
import java.net.DatagramSocket;
import java.net.InetAddress;
import java.net.SocketException;
import java.net.SocketTimeoutException;
import java.net.UnknownHostException;
import java.util.ArrayDeque;
import java.util.concurrent.atomic.AtomicInteger;

/**
 * DO NOT EDIT THIS FILE. - ÄLÄ MUOKKAA TÄTÄ TIEDOSTOA.
 * 
 * This class is used by the template to determine IP addresses and ports
 */

class Resolver extends Thread {

	private DatagramSocket serverSocket;
	private byte[] buf = new byte[256];
	private int port;
	private boolean serverMode = true;
	private int netType;
	private AtomicInteger serverPort;
	private String serverIPAddress;
	private ArrayDeque<Node> ipTable = new ArrayDeque<Node>();

	public Resolver(int port, boolean serverMode, int netType, int rootServerPort, String rootIPAddress) {
		this.port = port;
		this.serverMode = serverMode;
		this.netType = netType;
		this.serverPort = new AtomicInteger(rootServerPort);
		this.serverIPAddress = rootIPAddress;

		if (serverMode) {
			try {
				this.serverSocket = new DatagramSocket(port);
			} catch (SocketException e) {
				e.printStackTrace();
			}
			this.start();
		}
	}

	String[] resolve() throws UnknownHostException {
		String[] addresses = { "", "", "" };
		if (!serverMode) {

			try {
				InetAddress address = InetAddress.getByName("255.255.255.255");
				DatagramSocket socket = new DatagramSocket();
				socket.setBroadcast(true);

				String broadcastMessage = "getAddress";
				byte[] buffer = broadcastMessage.getBytes();

				DatagramPacket packet = new DatagramPacket(buffer, buffer.length, address, port);
				socket.send(packet);
				packet = new DatagramPacket(buf, buf.length);
				socket.setSoTimeout(2000);
				socket.receive(packet);
				addresses = (new String(packet.getData(), 0, packet.getLength())).split("/");
				socket.close();
			} catch (SocketException | SocketTimeoutException ex) {
				throw new UnknownHostException();
			}
			catch (IOException e) {
				e.printStackTrace();
			}

		}
		return addresses;
	}

	public void run() {
		System.out.println("Starting resolver");
		while (true) {
			try {
				ipTable.add(new Node(this.serverIPAddress, Integer.valueOf(0)));
				DatagramPacket packet = new DatagramPacket(buf, buf.length);
				serverSocket.receive(packet);

				InetAddress address = packet.getAddress();
				int port = packet.getPort();
				if (new String(packet.getData(), 0, packet.getLength()).equals("getAddress")) {
					String broadcastMessage = "//";
					switch (netType) {
					case 0:
						String clientPortString = serverPort.toString();
						serverPort.addAndGet(1);
						String serverPortString = serverPort.toString();
						broadcastMessage = serverPortString + "/localhost/" + clientPortString;
						break;
					case 1:
						Node node = ipTable.peekFirst();
						String clientIP = node.ip;
						node.clients += 1;
						if (node.clients > 1) {
							ipTable.removeFirst();
						}
						ipTable.addLast(new Node(address.getHostAddress(), 0));
						broadcastMessage = serverPort.toString() + "/" + clientIP + "/" + serverPort.toString();
						break;
					}

					byte[] buffer = broadcastMessage.getBytes();
					packet = new DatagramPacket(buffer, buffer.length, address, port);
					serverSocket.send(packet);
				}

			} catch (IOException e) {
				e.printStackTrace();
			}
		}
	}

	private class Node {
		public String ip;
		public int clients;

		public Node(String ip, Integer clients) {
			this.ip = ip;
			this.clients = clients;
		}

		public String toString() {
			return "IP: " + ip + " clients: " + clients;
		}
	}
}
